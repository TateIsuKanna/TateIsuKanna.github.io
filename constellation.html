<!DOCTYPE html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="色々な変調を可視化">
<meta name="keywords" content="AM,FM,PM,ASK,FSK,PSK,変調">
<meta name="generator" content="Vim">
<style>
        body{
                margin:0;
        }
        canvas{
                position:relative;
        }
        #constellationdiagram_canvas{
                border:solid 1px;
        }
        #graphs_container{
                display:flex;
        }
        #constellation_container,result_constellationdiagram_canvas{
                position:relative;
        }
        #distance{
                width:300px;
        }
</style>

<title>色々変調</title>
<input type="range" id="distance" min="1" max="32"  value="5">
<form name="source_input">
        <input name="c" checked type="radio" id="ASK">ASK(Amplitude Shift Keying)(振幅偏移変調)
        <input name="c" type="radio" id="PSK">PSK(Phase)(位相)
        <input name="c" type="radio" id="QAM">QAM(Quadrature Amplitude Modulation)(直角位相振幅変調)

        <input name="c" type="radio" id="AM">AM(包絡線検波用)
        <input name="c" type="radio" id="PM">PM

        <input name="c" type="radio" id="free">お好み
</form>
<span id="info"></span>
<div id="graphs_container">
        <div id="constellation_container">
                <canvas id="constellationdiagram_canvas" width="300" height="300"></canvas>
                <canvas id="result_constellationdiagram_canvas" width="300" height="300"></canvas>
        </div>
        <div>
        実部(cos成分)，I(In-phase)(同相成分)
        <canvas id="AM_canvas"></canvas>
        虚部(sin成分)，Q(Quadrature)(直交，直角)成分
        <canvas id="FM_canvas"></canvas>
        信号
        <canvas id="PM_canvas"></canvas>
        <p>↓フーリエ変換↓</p>
        実部(cos成分)，I(In-phase)(同相成分)
        <canvas id="FT_canvas_I"></canvas>
        虚部(sin成分)，Q(Quadrature)(直交，直角)成分
        <canvas id="FT_canvas_Q"></canvas>
        </div>
</div>
<script>
class Graph{
        constructor(canvas_id){
                this.element=document.getElementById(canvas_id);
                this.element.width=document.body.clientWidth-300;
                this.element.height=100;
                this.data=Array(this.element.width)
                this.ctx = this.element.getContext('2d');
        }
        draw(){
                this.ctx.clearRect(0,0,this.element.width,this.element.height);

                this.ctx.beginPath();
                this.ctx.moveTo(0,50);
                this.ctx.lineTo(this.element.width,50);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(0,this.data[0]+50);
                for(let t=1;t<this.data.length;++t){
                        this.ctx.lineTo(t,-this.data[t]+50);
                }
                this.ctx.stroke();
        }
        shift(){
                for(let t=1;t<this.data.length;++t){
                        this.data[t-1]=this.data[t];
                }
        }
}
class ConstellationDiagram{
        mouse(e){
                this.mouse_x=e.layerX;
                this.mouse_y=e.layerY;
        }
        constructor(canvas_id){
                this.element=document.getElementById(canvas_id);
                this.ctx = this.element.getContext('2d');
                let _this=this;
                this.element.addEventListener("mousemove",function(e){_this.mouse(e)});
        }
        draw_axis(){
                this.ctx.beginPath();
                this.ctx.moveTo(0,constellationdiagram_instance.element.height/2+.5);
                this.ctx.lineTo(constellationdiagram_instance.element.width,constellationdiagram_instance.element.height/2+.5);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(constellationdiagram_instance.element.width/2+.5,0);
                this.ctx.lineTo(constellationdiagram_instance.element.width/2+.5,constellationdiagram_instance.element.height);
                this.ctx.stroke();
        }
        draw_current_point(x,y){
                this.ctx.clearRect(0,0,constellationdiagram_instance.element.width,constellationdiagram_instance.element.height);
                this.draw_axis();
                this.ctx.beginPath();
                this.ctx.arc(x*(constellationdiagram_instance.element.width/2*.8)+(constellationdiagram_instance.element.width/2),-y*(constellationdiagram_instance.element.height/2*.8)+(constellationdiagram_instance.element.height/2), 5, 0, Math.PI*2, false);
                this.ctx.fillStyle = "rgb(0,0,255)"
                this.ctx.fill();
        }
}

let info_element=document.getElementById("info");
graphs=[new Graph("AM_canvas"),new Graph("FM_canvas"),new Graph("PM_canvas"),new Graph("FT_canvas_I"),new Graph("FT_canvas_Q")];
let constellationdiagram_instance=new ConstellationDiagram("constellationdiagram_canvas");
let result_constellationdiagram_instance=new ConstellationDiagram("result_constellationdiagram_canvas");

function update_info(d,t){
        info_element.innerText=d+t+" "+Math.log(d)/Math.log(2)+"bit/シンボル";
}

global_t=0;
function ft(){
        let re=0;
        let im=0;
        for(let t=graphs[2].data.length-1-16;t<graphs[2].data.length-1;++t){
                re+=graphs[2].data[t]*Math.cos((global_t-graphs[2].data.length+1+t)/8*Math.PI);
                im+=graphs[2].data[t]*Math.sin((global_t-graphs[2].data.length+1+t)/8*Math.PI);
        }
        graphs[3].data[graphs[3].data.length-1]=re/16;
        graphs[4].data[graphs[4].data.length-1]=im/16;

}
function draw() {
        //TODO:infoとかdistance_value_elementはdistance変更時だけにする
        let distance=Number(document.getElementById("distance").value);

        let data_x=(constellationdiagram_instance.mouse_x-constellationdiagram_instance.element.width/2)/(constellationdiagram_instance.element.width/2*.8);
        let data_y=-(constellationdiagram_instance.mouse_y-constellationdiagram_instance.element.height/2)/(constellationdiagram_instance.element.height/2*.8);

        data_x=Math.min(Math.max(data_x,-1),1);
        data_y=Math.min(Math.max(data_y,-1),1);

        if(document.source_input.ASK.checked){
                if(distance%2==0){
                        data_x=Math.round((data_x+(1/(distance-1)))*(distance-1)/2)/((distance-1)/2)-(1/(distance-1));
                }else{
                        data_x=Math.round(data_x*(distance-1)/2)/((distance-1)/2);
                }
                data_y=0;
                update_info(distance,"ASK");
        }
        if(document.source_input.PSK.checked){
                let angle=Math.round(Math.atan2(data_y,data_x)/(2*Math.PI)*distance)/distance*(2*Math.PI);
                data_x=Math.cos(angle);
                data_y=Math.sin(angle);
                update_info(distance,"PSK");
        }
        if(document.source_input.QAM.checked){
                distance*=2;
                data_x=Math.round((data_x-(1/(distance-1)))*(distance-1)/2)/((distance-1)/2)+(1/(distance-1));
                data_y=Math.round((data_y-(1/(distance-1)))*(distance-1)/2)/((distance-1)/2)+(1/(distance-1));
                update_info(distance,"QAM");
                let bits=Math.log(distance**2)/Math.log(2);
                if(Math.floor(bits)-bits==0){
                        info_element.style.fontWeight="bold";
                }else{
                        info_element.style.fontWeight="";
                }
        }

        if(document.source_input.AM.checked){
                data_x=Math.max(data_x,0);
                data_y=0;
                info_element.innerText="";
        }
        if(document.source_input.PM.checked){
                let angle=Math.atan2(data_y,data_x);
                data_x=Math.cos(angle);
                data_y=Math.sin(angle);
                info_element.innerText="";
        }
        if(document.source_input.free.checked){
                info_element.innerText="";
        }

        constellationdiagram_instance.draw_current_point(data_x,data_y);
        result_constellationdiagram_instance.draw_current_point(graphs[3].data[graphs[3].data.length-1]/20,graphs[4].data[graphs[4].data.length-1]/20);

        I=data_x*50/Math.sqrt(2)*Math.cos(global_t/8*Math.PI);
        Q=data_y*50/Math.sqrt(2)*Math.sin(global_t/8*Math.PI);
        graphs[0].data[graphs[0].data.length-1]=I;
        graphs[1].data[graphs[1].data.length-1]=Q;
        graphs[2].data[graphs[2].data.length-1]=I+Q;

        global_t++;

        for(let i=0;i<graphs.length;++i){
                graphs[i].shift();
                graphs[i].draw();
        }
        ft();
}
setInterval(draw,1);
</script>
